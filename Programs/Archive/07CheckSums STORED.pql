retrieval
. string * 32 DATE$ REC$
. string * 100 LINE$ IN$ OUT$ DBTODAY DBYEST FOLDER$
. integer * 1 NO YES MATCH
. integer * 2 DB# STAT# REC# RECS#
. real * 8 CXSUM# DIFF# YTOT# TTOT# GTOT#
. real * 8 array CXSUM (200)
. set NO DB# STAT# REC# RECS# DIFF# MATCH YTOT# TTOT# GTOT# CXSUM# (0) YES (1) CXSUM * (0)
. FOLDER$ = '\\192.168.53.246\Backups\' + datec(today(0),'YYYY\*')
. FILES# = filecnt(FOLDER$)
. DBTODAY = '<GDATA1>DCC\DB Copies\'
. DBYEST  = '<GBACKUP>' + datec(today(0),'YYYY\') + filen(FOLDER$,FILES# - 1) + '\'
|BEGIN
. open (REPORT) write append lrecl = 100
.  write (REPORT) '<tr>'
.  write (REPORT) '    <td bgcolor="#CCFF99" colspan="3">07 Check Sums</td>'
.  write (REPORT) '    <td bgcolor="#FFFFFF" align="center">' [timec(now(0),'hh:mm:ss')] '</td>'
.  write (REPORT) '</tr>'
. close (REPORT)
. include file DBSLIST
. set CXSUM * (0) DIFF# YTOT# TTOT# GTOT# CXSUM# (0)
. for DB# = 1,DB#C
.  if (STA$(DB#) <> 'Live') next for
.  RECS# = 0
.  IN$ = '<GDCC>BackupRoutine\Check Sums\' + trim(DB$N(DB#)) + '.txt'
.  ifthen (fileis(IN$) = YES)
.   execute subprocedure REGULARCXSUM
.  else
c.   execute subprocedure FIRSTCXSUM
.  endif
. end for
|
. subprocedure REGULARCXSUM
.  OUT$ = '<GDCC>BackupRoutine\Check Sums\' + trim(DB$N(DB#)) + '1.txt'
.  open (OUT$) dsnvar=OUT$ write lrecl=100
.   write (OUT$) 'Rec  Rec          Check Sum        Check Sum'
.    open (IN$) dsnvar=IN$ read lrecl=100
.     loop
.      read (IN$,end=DONE1) LINE$ (A100)
.      ifthen (picture(sbst(LINE$,36,10),'dd/dd/dddd') = MATCH)
.       DATE$ = sbst(LINE$,36,10)
.       write (OUT$) 'Num  Name         'DATE$'      '   [datec(today(0),'MM/DD/YYYY')]'      Result'
.       jump DONE1
.      endif
.     end loop
.     DONE1:
.    close (IN$)
.   write (OUT$) '---- ------------ ---------------- ---------------- -------'
.   pql connect database DB$N(DB#)
                prefix   DBTODAY
                iostat   STAT#
.    ifthen (STAT# < 0)
.     write '06CheckSums cannot connect to ' DB$N(DB#)
.     next for
.    else
.     open (IN$) dsnvar=IN$ read lrecl=100
.      loop
.       read (IN$,end=DONE2) LINE$ (A100)
.       ifthen (exists(numbr(sbst(LINE$,1,4))) = YES)
.        REC# = numbr(sbst(LINE$,1,4))
.        ifthen (len(trimlr(recname(REC#))) > 0)
.         execute dbms ['call DCCPROCF.BACKUPS.CXSUM (' + format(REC#) + ')']
.         CXSUM# = numbr(sglobal('GCXSUM'))
.        else
.         CXSUM# = 0
.        endif
.        TTOT# = TTOT# + CXSUM#
.        x = dglobal('GCXSUM')
.        write (OUT$) [sbst(LINE$,1,4)][sbst(LINE$,6,12)][sbst(LINE$,36,16)][pad(format(CXSUM#),' ',16,16)][CXSUM# - numbr(sbst(LINE$,35,16))]
.       elseif (sbst(LINE$,6,5) = 'TOTAL')
.        YTOT# = numbr(sbst(LINE$,36,16))
.        GTOT# = TTOT# - YTOT#
c write 'First TTOT# ' TTOT# (f16.5) 1x 'YTOT# ' YTOT# (f16.5) 1x  'Remainder '[TTOT# - YTOT#] 'GTOT# 'GTOT#
c .         write (OUT$) '---- ------------ ---------------- ---------------- -------'
c .         write (OUT$) '     TOTAL        'YTOT# (f16.5) 1x TTOT# (f16.5) 1x GTOT# (f16.5)
.       endif
.      end loop
.      DONE2:
.     close (IN$)
.    endif
.   pql disconnect database DB$N(DB#)
.  close (OUT$)
.  t = delfile(IN$)
.  t = rnmfile(OUT$,IN$)
cif eq 1,2
.         execute dbms 'call DCCPROCF.BACKUPS.CXEXPORT'
.         execute dbms 'call DCCPROCF.BACKUPS.CXVERIFY'
cif end
. end subprocedure REGULARCXSUM
|
. subprocedure FIRSTCXSUM
.   RECS# = 0
.   OUT$ = '<GDCC>BackupRoutine\Check Sums\' + trim(DB$N(DB#)) + '.txt'
.   open (OUT$) dsnvar=OUT$ write lrecl=100
.     pql connect database DB$N(DB#)
                  prefix   DBYEST
                  security 'riptide','',''
                  iostat   STAT#             
.       RECS# = nrecs(0)
.       for REC# = 1, RECS#
.         ifthen (len(trimlr(recname(REC#))) > 0)
.           execute dbms 'call DCCPROCF.BACKUPS.CXSUM (' + format(REC#) + ')'
.           CXSUM(REC#) = nglobal('GCXSUM')
.           YTOT# = YTOT# + CXSUM(REC#)
.           x = dglobal('GCXSUM')
.         endif
.       end for
.     pql disconnect database DB$N(DB#)
.     pql connect database DB$N(DB#)
                  prefix   DBTODAY
                  security 'riptide','',''
                  iostat   STAT#             
.       RECS# = nrecs(0)
.       write (OUT$) 'Rec  Rec          Check Sum        Check Sum'
.       write (OUT$) ['Num  Name         ' + datec(today(0) - 1,'MM/DD/YYYY') + '       ' + datec(today(0),'MM/DD/YYYY') + '       Result']
.       write (OUT$) '---- ------------ ---------------- ---------------- -------'
.       for REC# = 1, RECS#
.         ifthen (len(trimlr(recname(REC#))) > 0)
.           execute dbms 'call DCCPROCF.BACKUPS.CXSUM (' + format(REC#) + ')'
.           CXSUM# = numbr(sglobal('GCXSUM'))
.           TTOT# = TTOT# + CXSUM#
.           x = dglobal('GCXSUM')
.           DIFF# = CXSUM# - CXSUM(REC#)
.           write (OUT$) [pad(format(REC#),' ',4,4)]
                         [pad(recname(REC#),' ',12,12)]
                         [pad(format(CXSUM(REC#)),' ',16,16)] 
                         [pad(format(CXSUM#),' ',16,16)]
                         [pad(format(DIFF#),' ',20,20)]
.         endif
.       end for
.     pql disconnect database DB$N(DB#)
c write 'Second 'TTOT# YTOT# [TTOT# - YTOT#] GTOT#
c .     write (OUT$) '---- ------------ ---------------- ---------------- -------'
c .     write (OUT$) '     TOTAL        '[pad(format(YTOT#),' ',16,16)][pad(format(TTOT#),' ',16,16)][pad(format(TTOT# - YTOT#),' ',20,20)]
.   close (OUT$)
. end subprocedure FIRSTCXSUM
|
. subprocedure CXSUM
. integer *  1  MISS# NUM# STR#
. integer *  2  VAR# VARS# REC# CHAR#
. real    *  8  SUPERTOT SUM# NOW#
. string  * 32  VAR$ VALUE$ REC$
. set SUPERTOT STR# (0) NUM# (1)
. NOW# = now(0)
. missing values SUM# (-111 -112 -113)
. process cases
.   process rec <1>
.     REC# = <1>
.     VARS# = nvarsc(REC#)
.     for VAR# = 1, VARS#
.       VAR$ = stdname(varnamec(REC#,VAR#))
.       if (VAR$ = 'DWHO' or 'DCCWHO' or 'DSTAMP' or 'DCCDATE' or 'DCCTIME' or 'DCCEDITS') next for
.       TYPE# = vartype(VAR$)
.       set SUM# (0)
.       ifthen (TYPE# = NUM#)
.         SUM# = nget(VAR$)
.         MISS# = misnum(SUM#)
.         if (exists(SUM#) = 0) SUM# = numbr(miss(REC#,VAR$,MISS#))
.         if (exists(SUM#) = 0) SUM# = 0
.       elseif (TYPE# = STR#)
.         VALUE$ = trimlr(sget(VAR$))
.         MISS# = misnum(VALUE$)
.         for CHAR# = 1, len(VALUE$)
.           SUM# = SUM# + (ichar(sbst(VALUE$,CHAR#,1)))
.         end for
.       endif
.       SUPERTOT = SUPERTOT + SUM#
.     end for
.   end rec
. end cases
. x = dglobal('GCXSUM')
. x = globaln('GCXSUM',SUPERTOT)
. end subprocedure CXSUM
end retrieval
c.
c program
